--  MyString.adb
--
--  This file implements the operations defined in the MyString specification.
--  MyString is a SPARK-compatible bounded string type that avoids dynamic-length
--  operations, which are not verifiable in SPARK.
--
--  The functions provided here allow safe construction, conversion, comparison,
--  and manipulation of strings with a maximum length defined at instantiation.
--
--  This implementation includes contracts and loop invariants to support formal
--  verification in SPARK, except for routines like Get_Line which use Ada.Text_IO
--  and are excluded from analysis.
--
--  Do not modify this file.

with Ada.Text_IO;

package body Calculator is
   ---------------------------------------------------------------------------
   --  Initialisation
   ---------------------------------------------------------------------------
   procedure Init(C : out Calculator; Master_PIN: in PIN.PIN) is
   begin

      C.Locked:=True;
      C.Masterpin:=Master_PIN;
      C.Length:=0;
      C.Operand_stack:=(others=>0);

   end Init;


   -- "+"
   procedure Add(Number_1: in Integer; Number_2: in Integer;Result: out Integer) is
   begin
      Result:= Number_1+Number_2;
   end Add;

   -- "-"
   procedure Minus(Number_1: in Integer; Number_2: in Integer;Result: out Integer) is
   begin
      Result:= Number_1-Number_2;
   end Minus;

   -- "*"
   procedure Multiple(Number_1: in Integer; Number_2: in Integer;Result: out Integer) is
   begin
   end Multiple;

   -- "/"
   procedure Divide(Number_1: in Integer; Number_2: in Integer;Result: out Integer) is
   begin
   end Divide;

   -- push1 <NAME>
   procedure Push_1(C:in out Calculator;Number_1:in Integer) is
      begin
   end Push_1;

   -- push2 <NAME> <NAME>
   procedure Push_2(C:in out Calculator;Number_1:in Integer;Number_2:in Integer) is
   begin
   end Push_2;

   -- pop
   procedure Pop(C:in out Calculator;Result:out Integer)is
   begin
   end Pop;


   -- loadFrom <NAME>; loads the value stored at memory location loc and pushes it onto the operand stack
   procedure Load_From(C:in out Calculator;D : in out MemoryStore.Database; Loc: in MemoryStore.Location_Index) is
   begin
   end Load_From;


   -- storeTo <NAME>; pop the value from the top of the operand stack and stores it into memory location loc
   procedure Store_To(C:in out Calculator;D: in out MemoryStore.Database; Loc: in MemoryStore.Location_Index) is
   begin
   end Store_To;


   -- unlock <NAME>
   procedure Unlock(C:in out Calculator;P: in PIN.PIN) is
   begin
   end Unlock;

   -- lock <NAME>
   procedure Lock(C:in out Calculator;P: in out PIN.PIN) is
   begin
   end Lock;

   -- identify the command and call corresponding operation method
   procedure Calculation(C: in out Calculator; Operation: String) is
   begin
   end Calculation;


   ---------------------------------------------------------------------------
   --  Query helpers
   ---------------------------------------------------------------------------

   -- the Pin
   function Is_PIN(C : in Calculator;P: in PIN.PIN) return Boolean is
   begin
   end Is_PIN;


--     function Has (D : Database; Loc : Location_Index) return Boolean is
--       (D.Mem (Loc).Valid);
--
--     function Get (D : Database; Loc : Location_Index) return Int32 is
--       (D.Mem (Loc).Val);
--
--     function Length (D : Database) return Natural is
--       (D.Cnt);

   ---------------------------------------------------------------------------
   --  Update operations
   ---------------------------------------------------------------------------
--     procedure Put
--       (D   : in out Database;
--        Loc : in     Location_Index;
--        Val : in     Int32) is
--     begin
--        if not D.Mem (Loc).Valid then
--           -- inserting a brand-new entry
--           D.Cnt := D.Cnt + 1;
--        end if;
--        D.Mem (Loc).Valid := True;
--        D.Mem (Loc).Val   := Val;
--     end Put;
--
--     procedure Remove
--       (D   : in out Database;
--        Loc : in     Location_Index) is
--     begin
--        if D.Mem (Loc).Valid then
--           D.Mem (Loc).Valid := False;
--           D.Cnt             := D.Cnt - 1;
--        end if;
--     end Remove;

   ---------------------------------------------------------------------------
   --  Pretty-print for the "list" command
   ---------------------------------------------------------------------------
--     procedure Print (D : Database) is
--     begin
--        for Loc in Location_Index loop
--           if D.Mem (Loc).Valid then
--              Ada.Text_IO.Put ("   ");
--              Ada.Integer_Text_IO.Put (Loc, Width => 0);
--              Ada.Text_IO.Put (" => ");
--              Ada.Integer_Text_IO.Put (Integer (D.Mem (Loc).Val), Width => 0);
--              Ada.Text_IO.New_Line;
--           end if;
--        end loop;
--     end Print;



end Calculator;
